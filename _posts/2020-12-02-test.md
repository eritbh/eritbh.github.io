---
layout: post
title: Test post
modified: 2020-12-03
---
we're just gonna throw all the markdown here

# first heading

some words

another paragraph with a lot more words
another paragraph with a lot more words
another paragraph with a lot more words
another paragraph with a lot more words
another paragraph with a lot more words
another paragraph with a lot more words
another paragraph with a lot more words
another paragraph with a lot more words
another paragraph with a lot more words
another paragraph with a lot more words
another paragraph with a lot more words
another paragraph with a lot more words

## second heading

```js
// javascript code poggers
function pickRandom (arr) {
	return arr[Math.round(Math.random() * arr.length)];
}
```

### third heading

> Once upon a time, in a galxy far, far away...
>
> - iunno confucius probably

#### fourth heading

> how about one of them
>
>> nested quotes

##### fifth heading

###### sixth heading

did it break

```cpp
#pragma once

#include <vector>
#include <iostream>

/// Struct representing a node in a directed graph.
template <typename T>
struct Node
{
    T value;
    std::vector<Node<T> *> adjacents;
};

/// Class representing a directed graph whose nodes are represented by unique values.
template <typename T>
class Graph
{
private:
    std::vector<Node<T> *> nodes;

public:
    Graph() {}

    /// Adds a vertex to the graph with the given value. Returns `false` if the
    /// given value is already in the graph, `true` otherwise.
    bool addVertex(T value)
    {
        for (auto node : nodes)
            if (node->value == value)
                return false;
        nodes.push_back(new Node<T>{value});
        return true;
    }

    /// Adds an edge to the graph pointing from an initial node to a terminal
    /// node. Returns `false` if either value doesn't exist in the graph, or if
    /// the given edge already exists; returns `true` otherwise.
    bool addEdge(T initialValue, T terminalValue)
    {
        Node<T> *terminalNode;
        for (auto node : nodes)
        {
            if (node->value == terminalValue)
            {
                terminalNode = node;
                break;
            }
        }

        if (terminalNode == nullptr)
            return false;

        for (auto node : nodes)
        {
            if (node->value == initialValue)
            {
                node->adjacents.push_back(terminalNode);
                return true;
            }
        }
        return false;
    }

    /// Adds a pair of nodes to the graph, if they are not already in the graph,
    /// and adds an edge connecting the first to the second. Returns `false` if
    /// the edge already exists, `true` otherwise.
    bool addPair(T initial, T terminal)
    {
        addVertex(initial);
        addVertex(terminal);
        return addEdge(initial, terminal);
    }

    /// Calculates the in-degree of a given node. Returns `-1` if the given
    /// value is not in the graph.
    int inDegree(T value)
    {
        int result = 0;
        bool foundSelf = false;
        for (auto node : nodes)
        {
            if (node->value == value)
                foundSelf = true;

            for (auto adjacentNode : node->adjacents)
                if (adjacentNode->value == value)
                    result += 1;
        }
        return foundSelf ? result : -1;
    }

    /// Calculates the out-degree of a given node. Returns `-1` if the given
    /// value is not in the graph.
    int outDegree(T value)
    {
        for (auto node : nodes)
            if (node->value == value)
                return node->adjacents.size();
        return -1;
    }

    /// Retrieves all nodes with edges directed into the given node (i.e. the
    /// nodes constituting the in-degree).
    std::vector<T> findParents(T value)
    {
        std::vector<T> result;
        for (auto node : nodes)
        {
            for (auto adjacentNode : node->adjacents)
            {
                if (adjacentNode->value == value)
                {
                    result.push_back(node->value);
                    break;
                }
            }
        }
        return result;
    }

    /// Retrieves all nodes with edges directed out of the given node (i.e. the
    /// nodes constituting the in-degree).
    std::vector<T> findChildren(T value)
    {
        std::vector<T> result;
        for (auto node : nodes)
        {
            if (node->value == value)
            {
                for (auto adjacentNode : node->adjacents)
                {
                    result.push_back(adjacentNode->value);
                }
                return result;
            }
        }
        // node does not exist - we don't explicitly handle this case, an empty
        // result is returned
        return result;
    }

    /// Retrieves all values in the graph.
    std::vector<T> getAllValues()
    {
        std::vector<T> result;
        for (auto node : nodes)
        {
            result.push_back(node->value);
        }
        return result;
    }

    /// Prints the adjacency list.
    void printAdjacency()
    {
        for (auto node : nodes)
        {
            std::cout << node->value << ":";
            for (auto adjacentNode : node->adjacents)
            {
                std::cout << " " << adjacentNode->value;
            }
            std::cout << std::endl;
        }
    }
};
```
